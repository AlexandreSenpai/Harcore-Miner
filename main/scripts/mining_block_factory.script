go.property("block_size", 16)
go.property("grid_width", 5)
go.property("grid_height", 10)
go.property("grid_gap", 1)
go.property("anchor_point", vmath.vector3(224, 0, 0))

MINING_MAP = {}

BLOCK_MAP = {
	blue = {
		probability = 3,
		label = "BLUE",
		url = "/mining_blocks#block_blue_factory"
	},
	green = {
		probability = 3,
		label = "GREEN",
		url = "/mining_blocks#block_green_factory"
	},
	pink = {
		probability = 1,
		label = "PINK",
		url = "/mining_blocks#block_pink_factory"
	},
	red = {
		probability = 3,
		label = "RED",
		url = "/mining_blocks#block_red_factory"
	},
	white = {
		probability = 10,
		label = "WHITE",
		url = "/mining_blocks#block_white_factory"
	},
	stone = {
		probability = 80,
		label = "STONE",
		url = "/mining_blocks#block_stone_factory"
	}
}


function select_block_by_probability()
	local total_weight = 100
	local random_number = math.random() * total_weight

	local cumulative_weight = 0
	for block, definition in pairs(BLOCK_MAP) do
		cumulative_weight = cumulative_weight + definition["probability"]
		if random_number <= cumulative_weight then
			return definition["url"]
		end
	end
end

function calculate_margin(self, x, y)
	local x_margin = 0
	local y_margin = 0

	if x > 1 and x < self.grid_width + 1 then
		x_margin = self.grid_gap
	end

	if y > 1 and y < self.grid_height + 1 then
		y_margin = self.grid_gap
	end

	return x_margin, y_margin
end

function spawn_block(self, url, x, y)
	local x_margin, y_margin = calculate_margin(self, x, y)

	local x_pos = self.anchor_point.x + ((x - 1) * (self.block_size + x_margin))
	local y_pos = self.anchor_point.y + ((y - 1) * (self.block_size + y_margin))
	
	local block_id = factory.create(url, vmath.vector3(x_pos, y_pos, 1))
	print("Spawning ", block_id)
end

function generate_map(self)
	for y=1, self.grid_height do
		MINING_MAP[y] = {}
		for x=1, self.grid_width do
			local selected_block = select_block_by_probability()
			MINING_MAP[y][x] = selected_block
			spawn_block(self, selected_block, x, y)
		end
	end
end

function init(self)
	generate_map(self)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
